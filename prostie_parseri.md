# Простые парсеры

Прежде чем перейти к продолжению - оределимся что же в итоге мы хотим получить? Кроме задекларированной в самом начале цели генерации текста программы, нм сейчас потребуется некое внутренне представление. Его объявим следующим образом (для грамматики со сложением)

```
    ruleDef(parser,"Exp",fn(seq("digit",cChar("+"),"digit"),"$$ = $1 + $3"));
    ruleDef(parser, "digit", fn(oneOreMore(range("0","9")),"result = """"; for each x in $1 do result = result + x.value; enddo; $$ = number(result)"))
```

Фактически это и есть наша грамматика, просто записана немножко по другому. Пнимая к чему стремимся, осталось определить только используемые функции. 

cChar - парсер для 1 символа. Сравнение идет с учетом регистра символа
iChar - парсер для 1 символа. Сравнение идет без учета регистра символа
cString - парсер для строки. Сравнение идет с учетом регистра символов
iStrin - парсер для строки. Сравнение идет без учета регистра символов
range  - парсер для интервала, задается минимальное и максимальное значение элементов множества.
code - парсер реализует сравнение символа и кода символа
eof - парсер проверяет конец потока
any - парсер безусловного чтения 1 символа

negativeLookahead - парсер предпросмотра с инверсией
positiveLookahead  - парсер предпросмотра

seq - парсер собирающий несклько парсеров в один
alt - парсер альтернатив
zerroOrMore - парсер *
zerroOrOne - парсер ?
oneOrMore - парсер +
fn - парсер, выполняющий код в случае если зависимый парсер успешно отработал


